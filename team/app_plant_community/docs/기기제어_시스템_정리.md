# 🌱 기기제어 시스템 완전 정리

> 식물 농장 앱의 IoT 기기 제어 및 모니터링 시스템에 대한 완전한 가이드

---

## 📋 목차

1. [시스템 개요](#-시스템-개요)
2. [아키텍처](#-아키텍처)
3. [주요 컴포넌트](#-주요-컴포넌트)
4. [API 서비스](#-api-서비스)
5. [작업 히스토리](#-작업-히스토리)
6. [트러블슈팅](#-트러블슈팅)
7. [향후 개선사항](#-향후-개선사항)

---

## 🎯 시스템 개요

### 기능 요약
- **실시간 센서 모니터링**: 온도, 습도, 조도, 토양 수분 등 센서 데이터 조회
- **기기 원격 제어**: PUMP(물펌프), FAN(환풍기), LED(조명) 제어
- **자동/수동 모드**: AUTO 모드(센서 기반 자동 제어) / MANUAL 모드(사용자 직접 제어)
- **제어 로그 조회**: 모든 기기 제어 이력 기록 및 조회

### 지원 기기
| 기기명 | 아이콘 | 역할 | GPIO 핀 | 제어 방식 |
|--------|--------|------|---------|----------|
| **PUMP** | 💧 | 물 공급 펌프 | GPIO 6 | ACTIVE_LOW |
| **FAN** | 💨 | 환풍기/선풍기 | GPIO 13 | ACTIVE_HIGH |
| **LED** | 💡 | 식물 생장 조명 | GPIO 4 | ACTIVE_HIGH |

---

## 🏗 아키텍처

### 시스템 구성도
```
┌─────────────────┐       ┌──────────────────┐       ┌─────────────────┐
│  React Native   │──────▶│  Spring Boot     │──────▶│  Raspberry Pi   │
│  Expo App       │       │  Backend API     │       │  (GPIO 제어)    │
│                 │       │                  │       │                 │
│  - 센서 모니터링  │◀──────│  - REST API      │◀──────│  - Python       │
│  - 기기 제어 UI  │       │  - DB 연동       │       │  - GPIO 제어    │
│  - 로그 조회     │       │  - 로그 기록     │       │  - 센서 수집    │
└─────────────────┘       └──────────────────┘       └─────────────────┘
        ▲                          │                          │
        │                          ▼                          ▼
        │                  ┌──────────────┐          ┌────────────────┐
        │                  │   MariaDB    │          │   센서 장치들   │
        │                  │              │          │  - DHT11       │
        │                  │ - actuator   │          │  - CdS         │
        └──────────────────│ - sensor     │          │  - 토양습도     │
                          │ - member     │          └────────────────┘
                          └──────────────┘
```

### 네트워크 구성
```
192.168.30.97:5000    → Spring Boot 통합 API 서버 (센서, 액추에이터, 채팅 등)
192.168.30.97:8080    → Spring Boot IoT API 서버 (기기 제어 전용)
192.168.30.107:8080   → Spring Boot 캘린더 API 서버 (일기, 물주기 일정)
192.168.30.236        → Raspberry Pi (GPIO 제어 및 센서 데이터 수집)
192.168.30.97:3306    → MariaDB 데이터베이스 서버
```

> **중요**: 현재 프론트엔드는 `192.168.30.97:8080`을 기본으로 사용합니다.

---

## 📦 주요 컴포넌트

### 1. FarmManagement.jsx
> 📍 경로: `components/myFarm/FarmManagement.jsx`

농장 관리 메인 화면 - 센서 데이터 조회 및 기기 제어 통합 UI

#### 주요 기능
```jsx
// 1. 센서 데이터 실시간 모니터링
const loadSensorData = async () => {
  const data = await fetchSensorData();
  setSensorData(data);
};

// 2. 액추에이터 상태 조회
const loadActuatorStatus = async () => {
  const actuators = ['PUMP', 'FAN', 'LED'];
  const statusPromises = actuators.map(async (actName) => {
    const status = await fetchActuatorStatus(raspNum, actName);
    return { [actName]: status };
  });
  const statuses = await Promise.all(statusPromises);
  setActuatorStatus(statuses);
};

// 3. 기기 제어 핸들러
const handleActuatorControl = async (actName, command) => {
  if (command === 'AUTO') {
    // AUTO 모드로 전환
    await controlActuator(raspNum, actName, 'AUTO');
    setActuatorStatus(prev => ({
      ...prev,
      [actName]: { state: 'AUTO', mode: 'AUTO' }
    }));
  } else {
    // MANUAL 모드로 ON/OFF
    await controlActuator(raspNum, actName, command);
    setActuatorStatus(prev => ({
      ...prev,
      [actName]: { state: command, mode: 'MANUAL' }
    }));
  }
};

// 4. 모든 기기 AUTO 초기화
const resetAllToAuto = async () => {
  await Promise.all([
    controlActuator(raspNum, 'PUMP', 'AUTO'),
    controlActuator(raspNum, 'FAN', 'AUTO'),
    controlActuator(raspNum, 'LED', 'AUTO')
  ]);
};
```

#### State 관리
| State | 타입 | 용도 |
|-------|------|------|
| `sensorData` | Object | 센서 데이터 (온도, 습도, 조도 등) |
| `actuatorStatus` | Object | 각 기기의 상태 및 모드 |
| `loading` | Boolean | 초기 로딩 상태 |
| `refreshing` | Boolean | Pull-to-refresh 상태 |
| `autoRefresh` | Boolean | 자동 새로고침 활성화 여부 (5초 주기) |

#### UI 구성
```
┌─────────────────────────────────────┐
│  🌱 농장 #1                          │
│  마지막 업데이트: 2025-10-29 14:30  │
├─────────────────────────────────────┤
│  📊 센서 데이터          [🔄 자동]   │
│  ┌─────────┬─────────┬─────────┐   │
│  │  🌡️ 온도 │  💧 습도 │  ☀️ 조도 │   │
│  │  24.5°C │  65.0%  │  450 lx │   │
│  └─────────┴─────────┴─────────┘   │
├─────────────────────────────────────┤
│  ⚙️ 기기 제어                        │
│  ┌───────────────────────────────┐ │
│  │ 💧 PUMP    [AUTO] [ON] [OFF]  │ │
│  │ 상태: AUTO 모드                │ │
│  └───────────────────────────────┘ │
│  ┌───────────────────────────────┐ │
│  │ 💨 FAN     [AUTO] [ON] [OFF]  │ │
│  │ 상태: ON (수동)                │ │
│  └───────────────────────────────┘ │
│  ┌───────────────────────────────┐ │
│  │ 💡 LED     [AUTO] [ON] [OFF]  │ │
│  │ 상태: OFF (수동)               │ │
│  └───────────────────────────────┘ │
│                                     │
│  [🔄 모든 기기 AUTO로 전환]          │
│  [📊 제어 로그 보기]                 │
└─────────────────────────────────────┘
```

---

### 2. ActuatorLogs.jsx
> 📍 경로: `components/myFarm/ActuatorLogs.jsx`

기기 제어 이력 조회 화면

#### 주요 기능
```jsx
// 로그 필터링 조회
const loadLogs = async () => {
  const actName = selectedFilter === 'ALL' ? null : selectedFilter;
  const data = await fetchActuatorLogs(raspNum, actName, 100);
  setLogs(data);
};

// 날짜 포맷팅
const formatDate = (dateString) => {
  const date = new Date(dateString);
  return `${month}/${day} ${hours}:${minutes}:${seconds}`;
};

// 기기별 아이콘 매핑
const getDeviceIcon = (actName) => {
  switch (actName) {
    case 'PUMP': return '💧';
    case 'FAN': return '💨';
    case 'LED': return '💡';
    default: return '⚙️';
  }
};

// 모드별 배지 색상
const getModeColor = (mode) => {
  if (mode === 'AUTO') return COLORS.info;     // 파란색
  if (mode === 'MANUAL') return COLORS.warning; // 주황색
  return '#999'; // NULL
};
```

#### UI 구성
```
┌─────────────────────────────────────┐
│  📊 제어 로그                        │
│  [ALL] [PUMP] [FAN] [LED]           │
├─────────────────────────────────────┤
│  ┌─────────────────────────────┐   │
│  │ 💧 PUMP                      │   │
│  │ ON → OFF                     │   │
│  │ [AUTO] 10/29 14:25:30       │   │
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │ 💨 FAN                       │   │
│  │ OFF → ON                     │   │
│  │ [MANUAL] 10/29 14:20:15     │   │
│  └─────────────────────────────┘   │
│  ┌─────────────────────────────┐   │
│  │ 💡 LED                       │   │
│  │ ON → ON                      │   │
│  │ [AUTO] 10/29 14:15:00       │   │
│  └─────────────────────────────┘   │
└─────────────────────────────────────┘
```

---

## 🔌 API 서비스

### actuatorService.js
> 📍 경로: `services/actuatorService.js`

액추에이터 제어 및 조회 API 통신 레이어

#### API 엔드포인트
```javascript
const API_BASE_URL = 'http://192.168.30.97:8080';
```

#### 1. controlActuator() - 기기 제어
```javascript
export const controlActuator = async (raspNum, actName, command) => {
  // command에 따라 자동으로 mode 결정
  const mode = command === 'AUTO' ? 'AUTO' : 'MANUAL';
  
  const url = `${API_BASE_URL}/control/control`;
  const payload = { raspNum, actName, command, mode };
  
  const response = await fetch(url, {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify(payload),
  });
  
  if (!response.ok) {
    throw new Error(`제어 실패: ${response.status}`);
  }
  
  return await response.json();
};
```

**요청 예시**:
```json
POST /control/control
{
  "raspNum": "1",
  "actName": "PUMP",
  "command": "ON",
  "mode": "MANUAL"
}
```

**응답 예시**:
```json
{
  "success": true,
  "message": "제어 명령이 전송되었습니다."
}
```

#### 2. fetchActuatorStatus() - 기기 상태 조회
```javascript
export const fetchActuatorStatus = async (raspNum, actName) => {
  const response = await fetch(
    `${API_BASE_URL}/control/status?raspNum=${raspNum}&actName=${actName}`
  );
  
  if (!response.ok) throw new Error('상태 조회 실패');
  return await response.json();
};
```

**요청 예시**:
```
GET /control/status?raspNum=1&actName=PUMP
```

**응답 예시**:
```json
{
  "actName": "PUMP",
  "state": "ON",
  "mode": "MANUAL",
  "lastUpdated": "2025-10-29T14:30:00"
}
```

#### 3. fetchActuatorLogs() - 제어 로그 조회
```javascript
export const fetchActuatorLogs = async (raspNum, actName = null, limit = 50) => {
  let url = `${API_BASE_URL}/control/logs?raspNum=${raspNum}&limit=${limit}`;
  if (actName) url += `&actName=${actName}`;
  
  const response = await fetch(url);
  if (!response.ok) throw new Error('로그 조회 실패');
  return await response.json();
};
```

**요청 예시**:
```
GET /control/logs?raspNum=1&actName=PUMP&limit=100
```

**응답 예시**:
```json
[
  {
    "logId": 1234,
    "raspNum": "1",
    "actName": "PUMP",
    "stateBefore": "OFF",
    "stateAfter": "ON",
    "mode": "MANUAL",
    "logTime": "2025-10-29T14:30:00"
  },
  ...
]
```

#### 4. changeMode() - 모드 전환
```javascript
export const changeMode = async (raspNum, mode) => {
  const response = await fetch(`${API_BASE_URL}/control/mode`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ raspNum, mode }),
  });
  
  if (!response.ok) throw new Error('모드 변경 실패');
  return await response.json();
};
```

---

## 🛠 작업 히스토리

### Phase 1: MODE 컬럼 버그 수정 ✅
**문제**: 액추에이터 로그에서 MODE가 "알 수 없음"으로 표시됨

**원인**: 
- 백엔드 MyBatis Mapper XML에서 MODE 컬럼이 SELECT 쿼리에 포함되지 않음
- DB에는 데이터가 있지만 API 응답에서 누락

**해결**:
```xml
<!-- actuator-control-mapper.xml -->
<select id="getActuatorLogs">
  SELECT 
    LOG_ID as logId,
    RASP_NUM as raspNum,
    ACT_NAME as actName,
    STATE_BEFORE as stateBefore,
    STATE_AFTER as stateAfter,
    MODE as mode,           <!-- ✅ 추가 -->
    LOG_TIME as logTime
  FROM actuator_log
  WHERE RASP_NUM = #{raspNum}
  ORDER BY LOG_TIME DESC
  LIMIT #{limit}
</select>
```

**결과**: MODE 컬럼이 정상적으로 표시됨 (AUTO/MANUAL)

---

### Phase 2: FAN 모드 고정 버그 수정 🔧
**문제**: FAN이 AUTO 모드로 작동해도 앱에서 MANUAL로만 표시됨

**원인**: 
- Raspberry Pi의 Python GPIO 제어 스크립트에서 `log_actuator()` 함수의 기본값이 잘못 설정됨
- `mode="MANUAL"` → 모든 제어가 MANUAL로 기록됨

**해결** (사용자가 직접 수정):
```python
# ❌ 이전 코드
def log_actuator(act_name, state, mode="MANUAL"):
    ...

# ✅ 수정 코드
def log_actuator(act_name, state, mode="AUTO"):
    ...
```

**결과**: FAN의 실제 제어 모드가 올바르게 기록됨

---

### Phase 3: IP 주소 통합 🌐
**문제**: 
- 프론트엔드에서 여러 IP 주소 혼용 (192.168.30.107, 192.168.30.151, 192.168.30.97)
- 서버 변경 시마다 수동으로 IP 변경 필요

**해결**:
- 모든 서비스 파일의 API_BASE_URL을 `192.168.30.97`로 통합
- 포트 구분: 5000 (통합 API), 8080 (IoT 제어)

**변경된 파일들**:
```
✅ services/actuatorService.js    → 192.168.30.97:8080
✅ services/sensorService.js      → 192.168.30.97:5000
✅ services/boardService.js       → 192.168.30.97:5000
✅ services/chatService.js        → 192.168.30.97:5000
✅ services/calendarService.js    → 192.168.30.107:8080 (별도 서버)
```

---

### Phase 4: JSON Parse 에러 처리 🔧
**문제**: 
- 캘린더 API가 성공 시 JSON이 아닌 텍스트 응답 반환
- `JSON.parse()` 실패로 인한 앱 크래시

**원인**:
```javascript
// 서버 응답 예시
"일기가 작성되었습니다."  // ← 이건 JSON이 아님!
```

**해결**:
```javascript
// calendarService.js
export const addDiary = async (diaryData) => {
  const response = await fetch(`${API_BASE_URL}/diaries`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(diaryData),
  });
  
  const text = await response.text();
  
  if (!response.ok) {
    throw new Error(`일기 작성 실패: ${text}`);
  }
  
  // ✅ JSON 파싱 시도, 실패 시 텍스트 그대로 반환
  try {
    return JSON.parse(text);
  } catch (parseError) {
    return { success: true, message: text };
  }
};
```

**결과**: 서버가 텍스트를 반환해도 앱이 정상 작동

---

### Phase 5: 삭제 기능 추가 🗑️
**문제**: 캘린더에서 일기/물주기 일정 삭제 기능 없음

**구현**:

1. **Service 레이어**:
```javascript
// calendarService.js
export const deleteDiary = async (diaryId) => {
  const response = await fetch(`${API_BASE_URL}/diaries/${diaryId}`, {
    method: 'DELETE',
  });
  
  const text = await response.text();
  
  if (!response.ok) {
    throw new Error(`삭제 실패: ${text}`);
  }
  
  try {
    return JSON.parse(text);
  } catch {
    return { success: true, message: text };
  }
};

export const deleteWateringSchedule = async (wateringId) => {
  // 동일한 패턴
};
```

2. **Component 레이어**:
```javascript
// Calendar.jsx
import {
  deleteDiary,              // ✅ 추가
  deleteWateringSchedule,   // ✅ 추가
  ...
} from '../../services/calendarService';

const handleDeleteDiary = async (diaryId) => {
  Alert.alert(
    '일기 삭제',
    '정말로 삭제하시겠습니까?',
    [
      { text: '취소', style: 'cancel' },
      {
        text: '삭제',
        style: 'destructive',
        onPress: async () => {
          try {
            await deleteDiary(diaryId);
            Alert.alert('성공', '일기가 삭제되었습니다.');
            await loadAllData(); // 목록 새로고침
          } catch (error) {
            Alert.alert('오류', '삭제에 실패했습니다.');
          }
        }
      }
    ]
  );
};
```

3. **UI 추가**:
```jsx
<View style={styles.eventCard}>
  <View style={styles.eventCardContent}>
    <Text style={styles.eventTitle}>{event.title}</Text>
    <Text style={styles.eventTime}>{event.time}</Text>
  </View>
  
  {/* ✅ 삭제 버튼 */}
  <TouchableOpacity
    style={styles.deleteButton}
    onPress={() => 
      event.type === 'diary' 
        ? handleDeleteDiary(event.id)
        : handleDeleteWatering(event.id)
    }>
    <Text style={styles.deleteButtonText}>🗑️</Text>
  </TouchableOpacity>
</View>
```

**결과**: 사용자가 일기와 물주기 일정을 삭제할 수 있음

---

### Phase 6: Import 오류 수정 🐛
**문제**: 
- 삭제 기능 구현 후 `deleteDiary`와 `deleteWateringSchedule`가 정의되지 않음 오류
- import 문에서 함수가 누락됨

**원인**: 
- 파일이 편집되면서 import 문이 초기화됨 (포맷터 또는 수동 편집)

**해결**:
```javascript
// ❌ 이전 (오류 발생)
import {
  addDiary as apiAddDiary,
  addWateringSchedule as apiAddWatering,
  fetchDiaries,
  fetchWateringSchedules
} from '../../services/calendarService';

// ✅ 수정 (정상 작동)
import {
  addDiary as apiAddDiary,
  addWateringSchedule as apiAddWatering,
  deleteDiary,                    // ✅ 추가
  deleteWateringSchedule,         // ✅ 추가
  fetchDiaries,
  fetchWateringSchedules
} from '../../services/calendarService';
```

**결과**: 삭제 기능이 정상 작동

---

## 🔥 트러블슈팅

### 문제 1: 센서 데이터가 업데이트되지 않음

**증상**:
- 센서 데이터가 며칠 전 데이터로 고정됨
- "⚠️ 3일 전 데이터" 메시지 표시

**원인**:
- Raspberry Pi 센서 수집 프로세스가 중단됨
- DB에 새로운 데이터가 저장되지 않음

**해결**:
1. Raspberry Pi SSH 접속
2. 센서 수집 스크립트 재시작
3. 프로세스 상태 확인: `ps aux | grep sensor`

---

### 문제 2: 기기 제어 명령이 작동하지 않음

**증상**:
- 버튼 클릭 시 "제어에 실패했습니다" 알림
- 콘솔에 네트워크 오류 출력

**체크리스트**:
```
□ Raspberry Pi 전원이 켜져 있는가?
□ Spring Boot 서버가 실행 중인가?
□ 네트워크가 연결되어 있는가? (같은 Wi-Fi)
□ 방화벽이 8080 포트를 차단하고 있지 않은가?
□ API_BASE_URL이 올바른 IP인가?
```

**디버깅**:
```javascript
// actuatorService.js에서 로그 확인
console.log('📡 controlActuator 호출');
console.log('  URL:', url);
console.log('  Payload:', JSON.stringify(payload));
console.log('  응답 상태:', response.status);
```

**해결**:
1. 서버 재시작: `sudo systemctl restart spring-boot`
2. 네트워크 확인: `ping 192.168.30.97`
3. API 직접 테스트: Postman 또는 curl 사용

---

### 문제 3: MODE가 NULL로 표시됨

**증상**:
- 로그에서 MODE 배지가 "?" 표시
- DB에서 MODE 컬럼이 NULL

**원인**:
- Python GPIO 스크립트에서 `log_actuator()` 호출 시 mode 파라미터를 전달하지 않음

**해결**:
```python
# Python GPIO 제어 스크립트 수정
def control_pump(state):
    GPIO.output(PUMP_PIN, not state)  # ACTIVE_LOW
    current_mode = get_current_mode()  # AUTO 또는 MANUAL 확인
    log_actuator('PUMP', 'ON' if state else 'OFF', mode=current_mode)
    #                                                ^^^^^^^^^^^^^^^^^^
```

---

### 문제 4: 자동 새로고침이 너무 자주 발생함

**증상**:
- 앱 배터리 소모가 큼
- 네트워크 트래픽 과다

**해결**:
```javascript
// FarmManagement.jsx
const REFRESH_INTERVAL = 5000; // 5초 → 10초로 변경

// 또는 자동 새로고침 비활성화
const [autoRefresh, setAutoRefresh] = useState(false);
```

---

## 🚀 향후 개선사항

### 1. 사용자 인증 연동
**현재**:
```javascript
const raspNum = "1"; // 하드코딩된 농장 번호
```

**개선**:
```javascript
import { useAuth } from '../../contexts/AuthContext';

const { user } = useAuth();
const raspNum = user?.farmId || "1";
```

---

### 2. 실시간 알림 기능
**목표**:
- 센서 값이 위험 수준일 때 푸시 알림
- 기기 고장 시 즉시 알림

**구현 방안**:
- Firebase Cloud Messaging 연동
- WebSocket 또는 Server-Sent Events 사용

---

### 3. 데이터 시각화
**목표**:
- 센서 데이터 그래프 (시간대별 온도/습도 변화)
- 기기 가동 시간 통계

**라이브러리**:
- `react-native-chart-kit`
- `victory-native`

**예시 코드**:
```jsx
import { LineChart } from 'react-native-chart-kit';

<LineChart
  data={{
    labels: ['00:00', '06:00', '12:00', '18:00'],
    datasets: [{ data: [22.5, 24.0, 26.5, 25.0] }]
  }}
  width={screenWidth}
  height={220}
  chartConfig={{
    backgroundColor: COLORS.primary,
    decimalPlaces: 1,
  }}
/>
```

---

### 4. 예약 제어
**목표**:
- 특정 시간에 기기 자동 ON/OFF
- 반복 스케줄 설정 (매일 오전 9시 LED ON)

**DB 설계**:
```sql
CREATE TABLE actuator_schedule (
  SCHEDULE_ID INT PRIMARY KEY AUTO_INCREMENT,
  RASP_NUM VARCHAR(10),
  ACT_NAME VARCHAR(20),
  COMMAND VARCHAR(10),
  SCHEDULED_TIME TIME,
  REPEAT_TYPE ENUM('ONCE', 'DAILY', 'WEEKLY'),
  IS_ACTIVE TINYINT(1)
);
```

---

### 5. 에너지 절약 모드
**목표**:
- 야간 시간대 자동 LED OFF
- 토양 수분이 충분할 때 PUMP 자동 OFF

**구현**:
```javascript
const checkEnergySavingMode = () => {
  const hour = new Date().getHours();
  const isNight = hour >= 22 || hour < 6;
  
  if (isNight && actuatorStatus.LED?.state === 'ON') {
    handleActuatorControl('LED', 'OFF');
    console.log('⚡ 에너지 절약: LED 자동 꺼짐');
  }
};
```

---

## 📚 참고 자료

### API 문서
- Spring Boot REST API: http://192.168.30.97:8080/swagger-ui.html
- Raspberry Pi GPIO: https://pinout.xyz/

### 관련 파일
```
📁 components/myFarm/
  ├── FarmManagement.jsx      # 농장 관리 메인
  ├── ActuatorLogs.jsx         # 제어 로그
  └── Calendar.jsx             # 일정 관리

📁 services/
  ├── actuatorService.js       # 액추에이터 API
  ├── sensorService.js         # 센서 API
  └── calendarService.js       # 캘린더 API

📁 constants/
  └── myFarmConstant.js        # 색상/스타일 상수
```

### DB 스키마
```sql
-- 액추에이터 로그 테이블
CREATE TABLE actuator_log (
  LOG_ID INT PRIMARY KEY AUTO_INCREMENT,
  RASP_NUM VARCHAR(10),
  ACT_NAME VARCHAR(20),
  STATE_BEFORE VARCHAR(10),
  STATE_AFTER VARCHAR(10),
  MODE ENUM('AUTO', 'MANUAL'),
  LOG_TIME DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 센서 데이터 테이블
CREATE TABLE sensor (
  SENSOR_ID INT PRIMARY KEY AUTO_INCREMENT,
  RASP_NUM VARCHAR(10),
  TEMPERATURE DECIMAL(5,2),
  HUMIDITY DECIMAL(5,2),
  ILLUMINANCE INT,
  SOIL_MOISTURE INT,
  SENSOR_TIME DATETIME
);
```

---

## ✅ 체크리스트

### 개발 완료 항목
- [x] 센서 데이터 실시간 조회
- [x] 기기 ON/OFF 제어
- [x] AUTO/MANUAL 모드 전환
- [x] 제어 로그 조회 및 필터링
- [x] Pull-to-refresh 기능
- [x] 자동 새로고침 (5초 주기)
- [x] 모든 기기 AUTO 초기화
- [x] MODE 컬럼 버그 수정
- [x] JSON Parse 에러 처리
- [x] 일기/물주기 삭제 기능

### 진행 중 항목
- [ ] Python GPIO mode 기본값 수정 (사용자 작업)
- [ ] 센서 데이터 그래프 시각화
- [ ] 사용자별 농장 번호 연동

### 미착수 항목
- [ ] 실시간 알림 기능
- [ ] 예약 제어 기능
- [ ] 에너지 절약 모드
- [ ] 다국어 지원

---

**작성일**: 2025년 10월 29일  
**작성자**: GitHub Copilot  
**버전**: 1.0.0  
**최종 수정**: import 오류 수정 완료
